\section{Implementierungsphase}

    \subsection{Backend}

    Im Backend wurde ein neuer \Gls{controller} \texttt{DeviceAnalysisController} im Common-Modul erstellt, der den Endpunkt
    \texttt{api/core/DeviceAnalysis/{deviceId}/MessageStatistics} bereitstellt. Die Hauptaufgabe des \Gls{controller}s ist es, die
    passende Implementierung des \texttt{IDeviceAnalysisRepository} Interface basierend auf dem \texttt{deviceType} Query-Parameter auszuwählen
    und die Anfrage an diese Implementierung weiterzuleiten.

    Das \texttt{IDeviceAnalysisRepository} ist, wie der Name schon sagt, ein \Gls{repository}-Interface. Das heißt, es ist für die
    Kommunikation mit der Datenbank zuständig. Jede Implementierung des Interfaces ist für einen bestimmten Gerätetyp zuständig und hat
    eine Methode \texttt{IsRepositoryFor(deviceType)}, die überprüft, ob die Implementierung für den angegebenen Gerätetyp zuständig ist.

    Die Standard-Implementierung des \texttt{IDeviceAnalysisRepository} Interface im Common-Modul führt eine generische Datenbank-Abfrage aus,
    die alle Nachrichten von dem angegebenen Gerät in dem gewählten Zeitraum aggregiert und die Häufigkeit der Nachrichten pro
    \texttt{messageType} zählt. Diese Implementierung funktioniert für alle Gerätetypen, kann aber nur die generischen Nachrichtentypen verarbeiten.
    Ihre \texttt{IsRepositoryFor(deviceType)} Methode gibt immer \texttt{false} zurück, da sie für keinen spezifischen Gerätetyp zuständig ist.
    Sie wird als ein sog. \textit{Keyed Singleton} in der \acrshort{di} registriert, sodass der \Gls{controller} sie separat von den gerätespezifischen
    Implementierungen injizieren kann. Dies wird mit einem Attribut \texttt{[FromKeyedServices(key)]} im Konstruktor des \Gls{controller}s erreicht.

    Einige Gerätetypen (derzeit nur \textit{Secoris}) haben spezifischere Nachrichtentypen, die in der Standard-Implementierung nicht berücksichtigt
    werden können. Sie werden aus dem \texttt{rawPayload}-Feld der Nachricht extrahiert, welches gerätespezifisch deserialisiert werden muss. Außerdem
    müssen bei \textit{Secoris} einige Nachrichtentypen gefiltert werden, da sie für die Auswertung nicht relevant sind. Dafür registriert das
    \textit{Secoris}-Device-Modul eine eigene Implementierung des \texttt{IDeviceAnalysisRepository} Interface in der \acrshort{di}, die diese
    gerätespezifische Abfrage enthält. Ihre \texttt{IsRepositoryFor(deviceType)} Methode gibt \texttt{true} zurück, wenn der \texttt{deviceType}-Parameter
    den Wert \texttt{"hyen"} hat (der interne Name für \textit{Secoris}-Geräte).

    Die Ergebnisse der Datenbank-Abfrage werden in ein sog. \textit{Data Transfer Object} (DTO) umgewandelt und als JSON-Antwort an das Frontend
    zurückgegeben. Das DTO ist ein einfaches Objekt, das die Nachrichtentypen und deren Häufigkeit als Schlüssel-Wert-Paare enthält.

    Eine grafische Darstellung der Backend-Architektur des neuen Features ist in der Abbildung \ref{fig:backend-architecture} zu sehen.

    \subsection{Frontend} \label{sec:implementation-frontend}

    Im Frontend wurde mit dem \Gls{routing} und der Anzeigelogik in den Device-Modulen begonnen, weil das der Teil war, in dem es die größte Unsicherheit gab.
    Die Implementierung der Auswertung selbst im Device-Common-Modul war relativ einfach, da es nur eine Komponente mit einem Diagramm und einer Datumsauswahl ist.
    
    Es stellte sich heraus, dass dies die richtige Entscheidung war, da es erhebliche Herausforderungen bei der Integration der Auswertungsansicht in die Geräte-Detailansicht gab.
    Die Geräte-Detailansichten waren ursprünglich nicht dafür ausgelegt, dass auch Rollen wie \acrshort{ts} und \acrshort{pm} ohne Freigabe durch den \Gls{facherrichter} auf sie zugreifen können.
    An vielen Stellen wurde Gerätezugriff als eine Vorbedingung für die Anzeige von Inhalten angenommen, was zu Problemen führte.
    Dies wurde in der Planungsphase nicht erkannt, da diese Vorbedingung nur implizit in der bestehenden Codebasis vorhanden war und nicht dokumentiert wurde.

    Es zeigte sich zudem, dass das \Gls{routing} eine erhöhte Komplexität aufweist, siehe dazu Abbildung \ref{fig:frontend-routing}.
    Dabei muss man beachten, dass das \Gls{routing} in Angular nicht mit einfachen if/else/switch-Anweisungen gesteuert werden kann,
    sondern mit sogenannten \textit{Guards}.
    Es gibt mehrere Arten von Guards in Angular, die jeweils zu einem bestimmten Zeitpunkt im \Gls{routing}-Prozess ausgeführt werden
    und dementsprechend verschiedene Daten zur Verfügung haben. Das macht die Implementierung der komplexen Logik noch schwieriger.

    Diese Komplexität führte zu mehreren Herausforderungen während der Implementierung:
    \begin{itemize}
        \item Der Code für das \Gls{routing} und die Anzeigelogik wurde sehr unübersichtlich und schwer wartbar.
        \item Es war schwierig, alle möglichen Szenarien und Randfälle zu berücksichtigen und zu testen.
        \item Neue Device-Module in der Zukunft müssen die komplexe Logik ebenfalls implementieren, was zu Fehlern führen kann
        und die Integration neuer Geräte erschwert.
        \item Die Implementierung war in der vorgegebenen Zeit nicht vollständig abschließbar.
    \end{itemize}

    Aus diesen Gründen wurde beschlossen, das initiale Konzept \textbf{nicht} weiter zu verfolgen. Stattdessen wird die Auswertungsansicht
    als ein Dialogfenster implementiert, der von einem Button in dem Drei-Punkte-Menü der Gerätekachel auf der Suchseite geöffnet wird.
    Dies kann man in der folgenden Abbildung sehen (Systemanalyse ist der deutsche Begriff für Device Analysis):

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.5\textwidth]{../figures/card-screen.png}
        \caption{
            Gerätekachel mit geöffnetem Drei-Punkte-Menü und Systemanalyse-Button
        }
    \end{figure}

    Diese Änderung hat mehrere Vorteile:
    \begin{itemize}
        \item Das Menü, die Zugriffslogik und die Registrierung des Buttons sind bereits implementiert,
        sodass nur noch wenig Setup-Arbeit nötig ist.
        \item Es gibt keine Änderungen an der Geräte-Detailansicht oder dem \Gls{routing}, was die Komplexität erheblich reduziert.
        \item Die Implementierung ist in der restlichen Zeit abschließbar.
    \end{itemize}

    Die einzig verbleibende Herausforderung sind die Gerätedaten. In der Geräte-Detailansicht ist eine Übersicht
    der Gerätedaten bereits in einem Sidebar vorhanden. In einem Dialogfenster dagegen nicht -
    also müssen die Gerätedaten an das Dialogfenster übergeben und dort angezeigt werden.
    In der folgenden Abbildung ist dieser Dialog dargestellt:

    \begin{figure}[H]
        \centering
        \includegraphics[width=0.9\textwidth]{../figures/dialog-screen.png}
        \caption{
            Dialogfenster mit der Auswertungsansicht
        }
    \end{figure}

    Die Hauptaspekte der neuen Implementierung sind:
    \begin{itemize}
        \item Die Geräte registrieren in ihren Gerätekachel-Komponenten (siehe Quellcode \ref{code:frontend-secoris-action-registration})
        eine sog. \textit{DeviceAnalysisAction}, die ein Service im Device-Common-Modul zur Verfügung stellt.
        Dies erfolgt über eine Methode, die im Quellcode \ref{code:frontend-action-registration} dargestellt ist.
        Solche \textit{Actions} sind bereits für andere Features wie z.B. Zurücksetzen des Geräts implementiert.
        Somit können Geräte-Module nur die \textit{Actions} registrieren, die sie tatsächlich unterstützen,
        und diese ggf. konfigurieren.
        \item Der Button nimmt als Abhängigkeit ein \texttt{DeviceAnalysisProvider}, der die gerätespezifischen Daten
        für die Auswertungsansicht bereitstellt. Das ist notwendig, da die Komponente im Device-Common-Modul
        nicht wissen kann, welche Felder angezeigt werden müssen. Dies muss zur Laufzeit entschieden werden.
        Ein Beispiel dafür ist die Implementierung für Secoris im Quellcode \ref{code:frontend-secoris-device-analysis-provider}.
        \item Die Grafik wird wie geplant mit \texttt{Chart.js} umgesetzt. Es wird ein \texttt{Chart}-Objekt
        in der \texttt{ngOnInit()}-Methode (d.h. beim Initialisieren der Komponente) erstellt und konfiguriert.
        Bei Änderungen der Daten oder des ausgewählten Zeitraums wird das \texttt{data}-Attribut des \texttt{Chart}-Objekts
        aktualisiert und die \texttt{update()}-Methode aufgerufen, um die Grafik neu zu rendern.
    \end{itemize}

    \subsection{Tests}

        Die Tests sind für die Qualitätssicherung des neuen Features von entscheidender Bedeutung.
        Allerdings wird in unserem Entwicklungs-Team kein Testabdeckungsgrad vorgegeben. Es wird
        pragmatisch entschieden, welche Tests für ein Feature notwendig sind, um dessen Qualität sicherzustellen.
        
        Deswegen wird im Backend hauptsächlich auf Integrationstests gesetzt, um maximale Abdeckung
        bei minimalem Aufwand zu erreichen. Im Frontend werden Unit-Tests für die wichtigsten
        Komponenten und Services geschrieben, um deren Funktionalität zu überprüfen.

        \subsubsection{Backend}

        Im Backend werden Integrationstests für alle \textit{Repositories} geschrieben, um sicherzustellen, dass sie die Daten korrekt aus der Datenbank abrufen.
        Diese Tests haben die folgenden Merkmale:
        \begin{itemize}
            \item Sie sind in \textit{xUnit} geschrieben, da das Backend bereits dieses Test-Framework verwendet.
            \item Sie verwenden ein \textit{Test Container} — eine kleine, temporäre Instanz der \Gls{mongodb}-Datenbank, die nur für die Dauer der Tests läuft.
            Dadurch wird sichergestellt, dass die Tests in einer isolierten Umgebung laufen und nicht von externen Faktoren beeinflusst werden.
            \item Sie verwenden die Bibliothek \textit{Fluent Assertions}, um die Testergebnisse auf eine lesbare und verständliche Weise zu überprüfen.
            \item Um Testläufe kurz zu halten, deckt jeder Test so viele Szenarien wie möglich ab. Dies macht sie zwar nicht so isoliert wie Unit-Tests,
            aber es reduziert die Gesamtanzahl der Tests erheblich.
            \item Die Tests verwenden ein \textit{Arrange, Act, Assert (AAA)}-Muster, um die Struktur der Tests klar und konsistent zu halten.
        \end{itemize}

        Ein Beispiel für einen Integrationstest ist im Quellcode \ref{code:backend-integration-test} dargestellt.

        \subsubsection{Frontend}
        
        Als das erste Konzept für die Frontend-Implementierung verworfen wurde (siehe Abschnitt \ref{sec:implementation-frontend}),
        mussten auch viele Frontend-Tests verworfen werden, da sie auf dem ursprünglichen Konzept basierten. Nur
        eine Handvoll Tests konnte wiederverwendet werden.

        Für das neue Konzept werden aus folgenden Gründen \textbf{keine} automatisierten Tests geschrieben:
        \begin{itemize}
            \item Die Implementierung ist relativ einfach und besteht entweder aus UI-Komponenten oder aus
            Registrierungslogik, die bereits in anderen Teilen des Codes getestet wurde. Also wären hier
            \textit{Unit-Tests} nicht sehr nützlich.
            \item \textit{Integrationstests} werden im Frontend nur für geschäftskritische Features geschrieben,
            z.B. die Suchseite. Die Auswertungsansicht ist kein geschäftskritisches Feature, daher
            rechtfertigt sie keine \textit{Integrationstests}.
            \item Die für das Frontend-Testing eingeteilte Zeit wurde schon für die ursprüngliche Implementierung
            verwendet. Zeit von anderen Aufgaben abzuzweigen, um Tests zu schreiben, wäre aus oben genannten Gründen
            nicht effizient gewesen.
        \end{itemize}